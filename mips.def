/* This doesn't look like -*- C -*-, but it is! 
 *
 *
 * mips.def - MIPS machine definition 
 *
 * Modified by gaoke 2012-05-23
 *
 * This file defines all aspects of the SimpleScalar instruction set
 * architecture.  Each instruction set in the architecture has a DEFINST()
 * macro call included below.  The contents of a instruction definition are
 * as follows:
 *
 *   DEFINST(<enum>,			<opcode>,
 *	     <opname>,			<operands>,
 *	     <fu_req>,			<iflags>,
 *	     <output deps...>,		<input deps...>,
 *	     <expr>)
 *
 * Where:
 *
 *   <enum>	- is an enumerator that is returned when an instruction is
 *		  decoded by SS_OP_ENUM()
 *   <opcode>	- is the opcode of this instruction
 *   <opname>   - name of this instruction as a string, used by disassembler
 *   <operands>	- specified the instruction operand fields and their printed
 * 		  order for disassembly, used by disassembler, the recognized
 *		  operand field are (the instruction format is detailed in
 *		  the header file ss.h):
 *		    J - target field
 *		    j - PC relative target (offset + PC)
 *		    s - S register field
 *		    b - S register field (base register)
 *		    t - T register field
 *		    d - D register field
 *		    S - S register field (FP register)
 *		    T - T register field (FP register)
 *		    D - D register field (FP register)
 *		    o - load address offset (offset)
 *		    i - signed immediate field value
 *		    u - unsigned immediate field value
 *		    U - upper immediate field value
 *		    H - shift amount immediate field value
 *		    B - break code
 *
 *   <fu_req>	- functional unit requirements for this instruction
 *   <iflags>	- instruction flags, accessible via the SS_OP_FLAGS()
 *		  macro, flags are defined with F_* prefix in ss.h
 *   <output deps...>
 *		- a list of up to two output dependency designators, the
 *		  following designators are recognized (place an DNA in any
 *		  unused fields:
 *		    DGPR(N)   - general purpose register N
 *		    DGPR_D(N) - double word general purpose register N
 *		    DCGPR(N)  - general purpose register conditional on
 *			        pre/post- increment/decrement mode
 *		    DFPR_L(N) - floating-point register N, as word
 *		    DFPR_F(N) - floating-point reg N, as single-prec float
 *		    DFPR_D(N) - floating-point reg N, as double-prec double
 *		    DHI	      - HI result register
 *		    DLO	      - LO result register
 *		    DFCC      - floating point condition codes
 *		    DCPC      - current PC
 *		    DNPC      - next PC
 *		    DNA	      - no dependence
 *
 *   <input deps...>
 *		- a list of up to three input dependency designators, the
 *		  designators are defined above (place an DNA in any unused
 *		  fields.
 *
 *   <expr>	- a C expression that implements the instruction being
 * 		  defined, the expression must modify all architected state
 *		  affected by the instruction's execution, by default, the
 *		  next PC (NPC) value defaults to the current PC (CPC) plus
 *		  SS_INST_SIZE, as a result, only taken branches need to set
 *		  NPC
 *
 *		  The following predefined macros are available for use in
 *		  DEFINST() instruction expressions to access the value of
 *		  instruction operand/opcode field values:
 *
 *		    RS	    - RS register field value
 *		    RT	    - RT register field value
 *		    RD	    - RD register field value
 *		    FS	    - RS register field value
 *		    FT	    - RT register field value
 *		    FD	    - RD register field value
 *		    BS	    - RS register field value
 *		    TARG    - jump target field value
 *		    OFS	    - signed offset field value
 *		    IMM	    - signed offset field value
 *		    UIMM    - unsigned offset field value
 *		    SHAMT   - shift amount field value
 *		    BCODE   - break code field value
 *
 *		  To facilitate the construction of performance simulators
 *		  (which may want to specialize their architected state
 *		  storage format), all architected register and memory state
 *		  is accessed through the following macros:
 *
 *		    GPR(N)         - read general purpose register N
 *		    SET_GPR(N,E)   - write general purpose register N with E
 *		    GPR_D(N)       - read double word general purpose reg N
 *		    SET_GPR_D(N,E) - write double word gen purpose reg N w/ E
 *		    FPR_L(N)       - read floating-point register N, as word
 *		    SET_FPR_L(N,E) - floating-point reg N, as word, with E
 *		    FPR_F(N)       - read FP reg N, as single-prec float
 *		    SET_FPR_F(N,E) - write FP reg N, as single-prec float w/ E
 *		    FPR_D(N)       - read FP reg N, as double-prec double
 *		    SET_FPR_D(N,E) - write FP reg N, as double-prec double w/E
 *		    HI	           - read HI result register
 *		    SET_HI(E)      - write HI result register with E
 *		    LO	           - read LO result register
 *		    SET_LO(E)      - write LO result register with E
 *		    FCC	           - read floating point condition codes
 *		    SET_FCC(E)     - write floating point condition codes w/ E
 *		    CPC	           - read current PC register
 *		    NPC	           - read next PC register
 *		    SET_NPC(E)     - write next PC register with E
 *		    TPC	           - read target PC register
 *		    SET_TPC(E)     - write target PC register with E
 *
 *		    READ_SIGNED_BYTE(A)   - read signed byte from address A
 *		    READ_UNSIGNED_BYTE(A) - read unsigned byte from address A
 *		    READ_SIGNED_HALF(A)   - read signed half from address A
 *		    READ_UNSIGNED_HALF(A) - read unsigned half from address A
 *		    READ_WORD(A)          - read word from address A
 *		    WRITE_BYTE(E,A)       - write byte value E to address A
 *		    WRITE_HALF(E,A)       - write half value E to address A
 *		    WRITE_WORD(E,A)       - write word value E to address A
 *
 *		  Finally, the following helper functions are available to
 *		  assist in the construction of instruction expressions:
 *
 *		    INC_DEC(E,N,S) - execute E and update N as per pre/post-
 *				     incr/decr addressing sementics for an
 *				     access of S bytes
 *		    OVER(X,Y)      - check for overflow for X+Y, both signed
 *		    UNDER(X,Y)	   - check for umderflow for X-Y, both signed
 *		    DIV0(N)	   - check for divide by zero, N is denom
 *		    INTALIGN(N)    - check double word int reg N alignment
 *		    FPALIGN(N)	   - check double word FP reg N alignment
 *		    TALIGN(T)	   - check jump target T alignment
 */

DEFLINK(SPECIAL_INST, 0x00, "special", 0, 0x3f)
DEFLINK(REGIMM_INST , 0x01, "regimm", 16, 0x1f)
DEFLINK(COP1_INST   , 0x11, "cop1",   21, 0x1f)

/* first level opcode instructions */
#define JUMP_IMPL							\
  {									\
    SET_TPC((CPC & 036000000000) | (TARG << 2));			\
    is_jump[pid] = 1;							\
  }
DEFINST(JUMP,			0x02,
	"j",			"J",
	NA, 			F_CTRL|F_UNCOND|F_DIRJMP,
	DNA, DNA, 		DNA, DNA, DNA)

#define JAL_IMPL							\
  {									\
    SET_TPC((CPC & 036000000000) | (TARG << 2));			\
    SET_GPR(31, CPC + 8);						\
    is_jump[pid] = 1;							\
  }
DEFINST(JAL,			0x03,
	"jal",			"J",
	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
	DGPR(31), DNA,	 	DNA, DNA, DNA)

#define BEQ_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) == GPR(RT))						\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BEQ,			0x04,
	"beq",			"s,t,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)

#define BNE_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) != GPR(RT))						\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BNE,			0x05,
	"bne",			"s,t,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)

#define BLEZ_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) <= 0)							\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BLEZ,			0x06,
	"blez",			"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BGTZ_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) > 0)							\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BGTZ,			0x07,
	"bgtz",			"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define ADDI_IMPL							\
  {									\
    if (OVER(GPR(RS), IMM))						\
      DECLARE_FAULT(md_fault_overflow);					\
									\
    SET_GPR(RT, GPR(RS) + IMM);						\
  }
DEFINST(ADDI,			0x08,
	"addi",			"t,s,i",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)

#define ADDIU_IMPL							\
  {									\
    SET_GPR(RT, GPR(RS) + IMM);						\
  }
DEFINST(ADDIU,			0x09,
	"addiu",		"t,s,i",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)

#define SLTI_IMPL							\
  {									\
    if (GPR(RS) < IMM)							\
      SET_GPR(RT, 1);							\
    else								\
      SET_GPR(RT, 0);							\
  }
DEFINST(SLTI, 			0x0a,
	"slti",			"t,s,i",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)

#define SLTIU_IMPL							\
  {									\
    if ((unsigned)GPR(RS) < (unsigned)IMM)				\
      SET_GPR(RT, 1);							\
    else								\
      SET_GPR(RT, 0);							\
  }
DEFINST(SLTIU,			0x0b,
	"sltiu",		"t,s,i",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)

#define ANDI_IMPL							\
  {									\
    SET_GPR(RT, GPR(RS) & UIMM);					\
  }
DEFINST(ANDI,			0x0c,
	"andi",			"t,s,u",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA,	 	DGPR(RS), DNA, DNA)

#define ORI_IMPL							\
  {									\
    SET_GPR(RT, GPR(RS) | UIMM);					\
  }
DEFINST(ORI, 			0x0d,
	"ori",			"t,s,u",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)


#define XORI_IMPL							\
  {									\
    SET_GPR(RT, GPR(RS) ^ UIMM);					\
  }
DEFINST(XORI, 			0x0e,
	"xori",			"t,s,u",
	IntALU,			F_ICOMP|F_IMM,
	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)

#define LUI_IMPL							\
  {									\
    SET_GPR(RT, UIMM << 16);						\
  }
DEFINST(LUI, 			0x0f,
	"lui",			"t,U",
	IntALU,			F_ICOMP,
	DGPR(RT), DNA, 		DNA, DNA, DNA)

#define BEQL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) == GPR(RT))						\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
}
DEFINST(BEQL,			0x14,
	"beql",			"s,t,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)

#define BNEL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) != GPR(RT))						\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BNEL,			0x15,
	"bnel",			"s,t,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)

#define BLEZL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) <= 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BLEZL,			0x16,
	"blezl",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BGTZL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) > 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BGTZL,			0x17,
	"bgtzl",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define RDHWR_IMPL							\
  {									\
     if (RD != 29) { printf("Invalid inst: rdhwr $%d, $%d\n", RT, RD); abort(); } \
     SET_GPR(RT, tls_base);   \
  }
DEFINST(RDHWR,		0x1f,
	"rdhwr",		"t,d",
	IntALU,			F_ICOMP,
	DGPR(RT), DNA,	DGPR(RD), DNA, DNA)


/*
 * load/store operations
 *
 * NOTE: the out-of-order issue simulator(s) require that load and store
 * address computation input dependencies be placed in slots 1 and 2 of
 * the input dependency list slot 0 is reserved for the input dependency
 * of store values for store instructions
 */

#define LB_IMPL								\
  {									\
    sbyte_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_BYTE(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, (word_t)(sword_t)_result);				\
  }
DEFINST(LB,			0x20,
	"lb",			"t,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)


#define LH_IMPL								\
  {									\
    shalf_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_HALF(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, (word_t)(sword_t)_result);				\
  }
DEFINST(LH, 			0x21,
	"lh",			"t,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)

#define LW_IMPL								\
  {									\
    word_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_WORD(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, _result);						\
  }
DEFINST(LW,			0x23,
	"lw", 			"t,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)


#define LBU_IMPL							\
  {									\
    byte_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_BYTE(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, (word_t)_result);					\
  }
DEFINST(LBU, 			0x24, 
	"lbu", 			"t,o(b)",
	RdPort, 		F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)

#define LHU_IMPL							\
  {									\
    half_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_HALF(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, (word_t)_result);					\
  }
DEFINST(LHU, 			0x25, 
	"lhu", 			"t,o(b)",
	RdPort, 		F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)


#define LWC1_IMPL							\
  {									\
    word_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_WORD(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_FPR_L(FT, _result);						\
  }
DEFINST(LWC1, 			0x31,
	"lwc1",			"T,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DFPR_L(FT), DNA,	DNA, DGPR(BS), DNA)

#define LDC1_IMPL							\
  {									\
    word_t _result_hi, _result_lo;					\
    enum md_fault_type _fault;						\
									\
    if ((FT) & 01)							\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    _result_hi = READ_WORD(GPR(BS) + OFS, _fault);			\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    _result_lo = READ_WORD(GPR(BS) + OFS + 4, _fault);			\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    /*printf("pc[%8x] ldc1 FT(%d) result_hi(%8x) : FT+1(%d)  result_lo(%8x)\n" ,regs.regs_PC ,FT,_result_hi,FT+1,_result_lo);*/\
    SET_FPR_L(FT, _result_hi);						\
    SET_FPR_L((FT) + 1, _result_lo);					\
  }

DEFINST(LDC1,			0x35,
	"ldc1",			"T,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DFPR_D(FT), DNA,	DNA, DGPR(BS), DNA)

#if (!defined(MD_CROSS_ENDIAN) && defined(BYTES_BIG_ENDIAN)) || (defined(MD_CROSS_ENDIAN) && defined(BYTES_LITTLE_ENDIAN))
#define LWL_IMPL							\
  {									\
    md_addr_t _temp_bs;							\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    /* BS may == RT */							\
    _temp_bs = GPR(BS);							\
    _lr_temp = READ_WORD(WL_BASE(_temp_bs + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    SET_GPR(RT, ((GPR(RT) & WL_PROT_MASK1(_temp_bs + OFS))		\
		 | ((_lr_temp << (8 * WL_SIZE(_temp_bs + OFS)))		\
		    & ~WL_PROT_MASK1(_temp_bs + OFS))));		\
  }
DEFINST(LWL,			0x22,
        "lwl",			"t,o(b)",
        RdPort,			F_MEM|F_LOAD|F_DISP,
        DGPR(RT), DNA,		DNA, DGPR(BS), DNA,)

#define LWR_IMPL							\
  {									\
    md_addr_t _temp_bs;							\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    /* BS may == RT */							\
    _temp_bs = GPR(BS);							\
    _lr_temp = READ_WORD(WR_BASE(_temp_bs + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    SET_GPR(RT, ((GPR(RT) & ~WR_PROT_MASK1(_temp_bs + OFS))		\
		 | ((_lr_temp >> (8 * (4 - WR_SIZE(_temp_bs + OFS))))	\
		    & WR_PROT_MASK1(_temp_bs + OFS))));			\
  }
DEFINST(LWR,			0x26,
        "lwr",			"t,o(b)",
        RdPort,			F_MEM|F_LOAD|F_DISP,
        DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
#else /* defined BYTES_LITTLE_ENDIAN */
#define LWL_IMPL							\
  {									\
    md_addr_t _temp_bs;							\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    /* BS may == RT */							\
    _temp_bs = GPR(BS);							\
    _lr_temp = READ_WORD(WL_BASE(_temp_bs + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    SET_GPR(RT, ((GPR(RT) & WR_PROT_MASK1(_temp_bs + OFS))		\
		 | ((_lr_temp << (8 * (WL_SIZE(_temp_bs + OFS) -1)))	\
		    & ~WR_PROT_MASK1(_temp_bs + OFS))));		\
  }
DEFINST(LWL,			0x22,
        "lwl",			"t,o(b)",
        RdPort,			F_MEM|F_LOAD|F_DISP,
        DGPR(RT), DNA,		DNA, DGPR(BS), DNA)

#define LWR_IMPL							\
  {									\
    md_addr_t _temp_bs;							\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    /* BS may == RT */							\
    _temp_bs = GPR(BS);							\
    _lr_temp = READ_WORD(WR_BASE(_temp_bs + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    SET_GPR(RT, ((GPR(RT) & ~WL_PROT_MASK2(_temp_bs + OFS))		\
		 | ((_lr_temp >> (8 * (WR_SIZE(_temp_bs + OFS)-1)))	\
		    & WL_PROT_MASK2(_temp_bs + OFS))));			\
  }
DEFINST(LWR,			0x26,
        "lwr",			"t,o(b)",
        RdPort,			F_MEM|F_LOAD|F_DISP,
        DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
#endif
  
#define SB_IMPL								\
  {									\
    byte_t _src;							\
    enum md_fault_type _fault;						\
									\
    _src = (byte_t)(word_t)GPR(RT);					\
    WRITE_BYTE(_src, GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SB, 			0x28, 
	"sb", 			"t,o(b)",
	WrPort, 		F_MEM|F_STORE|F_DISP,
	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)

#define SH_IMPL								\
  {									\
    half_t _src;							\
    enum md_fault_type _fault;						\
									\
    _src = (half_t)(word_t)GPR(RT);					\
    WRITE_HALF(_src, GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SH, 			0x29, 
	"sh", 			"t,o(b)",
	WrPort, 		F_MEM|F_STORE|F_DISP,
	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)

#define SW_IMPL								\
  {									\
    word_t _src;							\
    enum md_fault_type _fault;						\
									\
    _src = (word_t)GPR(RT);						\
    WRITE_WORD(_src, GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SW, 			0x2b, 
	"sw", 			"t,o(b)",
	WrPort, 		F_MEM|F_STORE|F_DISP,
	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)

#define SWC1_IMPL							\
  {									\
    enum md_fault_type _fault;						\
									\
    WRITE_WORD(FPR_L(FT), GPR(BS) + OFS, _fault);			\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SWC1, 			0x39, 
	"swc1",			"T,o(b)",
	WrPort, 		F_MEM|F_STORE|F_DISP,
	DNA, DNA,		DFPR_L(FT), DGPR(BS), DNA)

/* FIXME: this code not fault-safe, yet... */
#define SDC1_IMPL							\
  {									\
    enum md_fault_type _fault;						\
									\
    if ((FT) & 01)							\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    WRITE_WORD(FPR_L(FT), GPR(BS) + OFS, _fault);			\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    WRITE_WORD(FPR_L((FT)+1), GPR(BS) + OFS + 4, _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SDC1,			0x3d,
	"sdc1",			"T,o(b)",
	WrPort,			F_MEM|F_STORE|F_DISP,
	DNA, DNA,		DFPR_D(FT), DGPR(BS), DNA)

#if (!defined(MD_CROSS_ENDIAN) && defined(BYTES_BIG_ENDIAN)) || (defined(MD_CROSS_ENDIAN) && defined(BYTES_LITTLE_ENDIAN))
#define SWL_IMPL							\
  {									\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    _lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    _lr_temp = (((GPR(RT) >> (8 * WL_SIZE(GPR(BS) + OFS)))		\
		 & WL_PROT_MASK2(GPR(BS) + OFS))			\
		| (_lr_temp & ~WL_PROT_MASK2(GPR(BS) + OFS)));		\
    WRITE_WORD(_lr_temp, WL_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SWL,			0x2a,
        "swl",			"t,o(b)",
        WrPort,			F_MEM|F_STORE|F_DISP,
        DNA, DNA,		DGPR(RT), DGPR(BS), DNA)

#define SWR_IMPL							\
  {									\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    _lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    _lr_temp = (((GPR(RT) << (8 * (4 - WR_SIZE(GPR(BS) + OFS))))	\
		 & ~WR_PROT_MASK2(GPR(BS) + OFS))			\
		| (_lr_temp & WR_PROT_MASK2(GPR(BS) + OFS)));		\
    WRITE_WORD(_lr_temp, WR_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SWR,			0x2e,
        "swr",			"t,o(b)",
        WrPort,			F_MEM|F_STORE|F_DISP,
        DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
#else /* BYTES_LITTLE_ENDIAN */
#define SWL_IMPL							\
  {									\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    _lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    _lr_temp = (((GPR(RT) >> (8 * (4 - WR_SIZE(GPR(BS) + OFS))))	\
		 & WR_PROT_MASK2(GPR(BS) + OFS))			\
		| (_lr_temp & ~WR_PROT_MASK2(GPR(BS) + OFS)));		\
    WRITE_WORD(_lr_temp, WL_BASE(GPR(BS)+OFS), _fault);			\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SWL,			0x2a,
        "swl",			"t,o(b)",
        WrPort,			F_MEM|F_STORE|F_DISP,
        DNA, DNA,		DGPR(RT), DGPR(BS), DNA)

#define SWR_IMPL							\
  {									\
    word_t _lr_temp;							\
    enum md_fault_type _fault;						\
									\
    _lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
									\
    _lr_temp = (((GPR(RT) << (8 * (4 - WL_SIZE(GPR(BS) + OFS))))	\
		   & ~WL_PROT_MASK1(GPR(BS) + OFS))			\
		  | (_lr_temp & WL_PROT_MASK1(GPR(BS) + OFS)));		\
    WRITE_WORD(_lr_temp, WR_BASE(GPR(BS) + OFS), _fault);		\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
  }
DEFINST(SWR,			0x2e,
        "swr",			"t,o(b)",
        WrPort,			F_MEM|F_STORE|F_DISP,
        DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
        
#endif

/* ll == lw, sc == sw + rt <- 1, */
#define LL_IMPL								\
  {									\
    word_t _result;							\
    enum md_fault_type _fault;						\
									\
    _result = READ_WORD(GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
     DECLARE_FAULT(_fault);						\
    SET_GPR(RT, _result);						\
  }
DEFINST(LL,			0x30,
	"ll", 			"t,o(b)",
	RdPort,			F_MEM|F_LOAD|F_DISP,
	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)

#define SC_IMPL								\
  {									\
    word_t _src;							\
    enum md_fault_type _fault;						\
									\
    _src = (word_t)GPR(RT);						\
    WRITE_WORD(_src, GPR(BS) + OFS, _fault);				\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    SET_GPR(RT, 1);							\
  }
DEFINST(SC, 			0x38, 
	"sc", 			"t,o(b)",
	WrPort, 		F_MEM|F_STORE|F_DISP,
	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)

/* special instrutions. major opcode == 0 */
CONNECT(SPECIAL_INST)

/*
 * Integer ALU operations
 */

#define SLL_IMPL							\
  {									\
    SET_GPR(RD, GPR(RT) << SHAMT);					\
  }
DEFINST(SLL, 			0x00,
	"sll", 			"d,t,H", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)

#define SLLV_IMPL							\
  {									\
    SET_GPR(RD, GPR(RT) << (GPR(RS) & 0x1f));				\
  }
DEFINST(SLLV, 			0x04,
	"sllv", 		"d,t,s", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)

#ifdef FAST_SRL
#define SRL_IMPL							\
  {									\
    SET_GPR(RD, ((unsigned)GPR(RT)) >> SHAMT);				\
  }
#else /* !FAST_SRL */
#define SRL_IMPL							\
  {									\
    /* C standard says >> is implementation specific;			\
       could be SRL, SRA, or dependent on signdness of operand */	\
    if ((SHAMT) != 0)							\
      {									\
	word_t _rd;							\
									\
	_rd = (((unsigned)GPR(RT)) >> 1) & ~0x80000000;	/* first bit */	\
	SET_GPR(RD, (_rd >> ((SHAMT) - 1)));		/* rest */	\
      }									\
    else								\
      {									\
	SET_GPR(RD, GPR(RT));						\
      }									\
  }
#endif /* FAST_SRL */
DEFINST(SRL, 			0x02,
	"srl", 			"d,t,H", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)

#ifdef FAST_SRL
#define SRLV_IMPL							\
  {									\
    SET_GPR(RD, ((unsigned)GPR(RT)) >> (GPR(RS) & 0x1f));		\
  }
#else /* !FAST_SRL */
#define SRLV_IMPL							\
  {									\
    int _shamt = GPR(RS) & 0x1f;						\
									\
    /* C standard says >> is implementation specific;			\
       could be SRL, SRA, or dependent on signdness of operand */	\
    if (_shamt != 0)							\
      {									\
	word_t _rd;							\
									\
	_rd = (((unsigned)GPR(RT)) >> 1) & ~0x80000000;	/* first bit */	\
	SET_GPR(RD, (_rd >> (_shamt - 1)));		/* rest */	\
      }									\
    else								\
      {									\
	SET_GPR(RD, GPR(RT));						\
      }									\
  }
#endif /* FAST_SRL */
DEFINST(SRLV, 			0x06,
	"srlv", 		"d,t,s", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)

#ifdef FAST_SRA
#define SRA_IMPL							\
  {									\
    SET_GPR(RD, ((signed)GPR(RT)) >> SHAMT);				\
  }
#else /* !FAST_SRA */
#define SRA_IMPL							\
  {									\
    int _i;								\
									\
    /* C standard says >> is implementation specific;			\
       could be SRL, SRA, or dependent on sign-ness of operand */	\
    /* rd <- [rt] >> SHAMT */						\
    if (GPR(RT) & 0x80000000)						\
      {									\
        SET_GPR(RD, GPR(RT));						\
        for (_i = 0; _i < SHAMT; _i++)					\
	  {								\
	    SET_GPR(RD, (GPR(RD) >> 1) | 0x80000000);			\
	  }								\
      }									\
    else								\
      {									\
	SET_GPR(RD, GPR(RT) >> SHAMT);					\
      }									\
  }
#endif /* FAST_SRA */
DEFINST(SRA, 			0x03,
	"sra", 			"d,t,H", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)

#ifdef FAST_SRA
#define SRAV_IMPL							\
  {									\
    SET_GPR(RD, ((signed)GPR(RT)) >> (GPR(RS) & 0x1f));			\
  }
#else /* !FAST_SRA */
#define SRAV_IMPL							\
  {									\
    int _i;								\
    int _shamt = GPR(RS) & 0x1f;						\
									\
    /* C standard says >> is implementation specific;			\
       could be SRL, SRA, or dependent on sign-ness of operand */	\
    /* rd <- [rt] >> SHAMT */						\
    if (GPR(RT) & 0x80000000)						\
      {									\
        SET_GPR(RD, GPR(RT));						\
        for (_i = 0; _i < _shamt; _i++)					\
	  {								\
	    SET_GPR(RD, (GPR(RD) >> 1) | 0x80000000);			\
	  }								\
      }									\
    else								\
      {									\
	SET_GPR(RD, GPR(RT) >> _shamt);					\
      }									\
  }
#endif /* FAST_SRA */
DEFINST(SRAV, 			0x07,
	"srav", 		"d,t,s",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)

#define JR_IMPL								\
  {									\
    if (GPR(RS) & 0x3)							\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_TPC(GPR(RS));							\
    is_jump[pid] = 1;							\
  }
DEFINST(JR, 			0x08,
	"jr", 			"s", 
	NA, 			F_CTRL|F_UNCOND|F_INDIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define JALR_IMPL							\
  {									\
    if (GPR(RS) & 0x3)							\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_GPR(RD, CPC + 8);						\
    SET_TPC(GPR(RS));							\
    is_jump[pid] = 1;							\
  }
DEFINST(JALR,	 		0x09,
	"jalr", 		"d,s",
	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP|F_CALL,
	DGPR(RD), DNA,		DGPR(RS), DNA, DNA)

#define MOVZ_IMPL                                                       \
  {                                                                     \
    if(!GPR(RT))                                                        \
      SET_GPR(RD, GPR(RS));                                             \
  }
DEFINST(MOVZ,                   0x0a,
        "movz",                 "d,s,t",
        IntALU,                 F_ICOMP,
        DGPR(RD), DNA,          DGPR(RS), DGPR(RT), DNA)

#define MOVN_IMPL                                                       \
  {                                                                     \
    if(GPR(RT))                                                         \
      SET_GPR(RD, GPR(RS));                                             \
  }
DEFINST(MOVN,                   0x0b,
        "movn",                 "d,s,t",
        IntALU,                 F_ICOMP,
        DGPR(RD), DNA,          DGPR(RS), DGPR(RT), DNA)


#define SYSCALL_IMPL							\
  {									\
    SYSCALL(inst);							\
  }
DEFINST(SYSCALL, 		0x0c,
	"syscall", 		"",
	NA, 			F_TRAP,
	DNA, DNA,		DNA, DNA, DNA)

#define BREAK_IMPL							\
  {									\
    /* NOTE: these are decoded speculatively, as they occur in integer	\
       divide sequences, however, they should NEVER be executed under	\
       non-exception conditions */					\
    DECLARE_FAULT(md_fault_break);					\
  }

DEFINST(BREAK,			0x0d,
	"break",		"B",
	NA,			F_TRAP,
	DNA, DNA,		DNA, DNA, DNA)

#define SYNC_IMPL							\
  {									\
  }

DEFINST(SYNC,			0x0f,
	"sync",		"",
	NA,			F_ICOMP,
	DNA, DNA,		DNA, DNA, DNA)

#define MFHI_IMPL							\
  {									\
    SET_GPR(RD, HI);							\
  }
DEFINST(MFHI, 			0x10,
	"mfhi", 		"d",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DHI, DNA, DNA)

#define MTHI_IMPL							\
  {									\
    SET_HI(GPR(RS));							\
  }
DEFINST(MTHI, 			0x11,
	"mthi", 		"s",
	IntALU, 		F_ICOMP,
	DHI, DNA,		DGPR(RS), DNA, DNA)

#define MFLO_IMPL							\
  {									\
    SET_GPR(RD, LO);							\
  }
DEFINST(MFLO, 			0x12,
	"mflo", 		"d", 
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DLO, DNA, DNA)

#define MTLO_IMPL							\
  {									\
    SET_LO(GPR(RS));							\
  }
DEFINST(MTLO, 			0x13,
	"mtlo", 		"s", 
	IntALU, 		F_ICOMP,
	DLO, DNA,		DGPR(RS), DNA, DNA)

#define MULT_IMPL							\
  {									\
    bool_t _sign1, _sign2;						\
    int _i;								\
    sword_t _op1, _op2;							\
									\
    /* HI,LO <- [rs] * [rt], integer product of [rs] & [rt] to HI/LO */	\
    _sign1 = _sign2 = FALSE;						\
    SET_HI(0);								\
    SET_LO(0);								\
    _op1 = GPR(RS);							\
    _op2 = GPR(RT);							\
									\
    /* for multiplication, treat -ve numbers as +ve numbers by		\
       converting 2's complement -ve numbers to ordinary notation */	\
                                                                        \
    /* octal, check whether the operand is negative */                  \
    if (_op1 & 020000000000)						\
      {									\
	_sign1 = TRUE;							\
	_op1 = (~_op1) + 1;						\
      }									\
    if (_op2 & 020000000000)						\
      {									\
	_sign2 = TRUE;							\
	_op2 = (~_op2) + 1;						\
      }									\
    if (_op1 & 020000000000)						\
      SET_LO(_op2);							\
									\
    for (_i = 0; _i < 31; _i++)						\
      {									\
	SET_HI(HI << 1);						\
	SET_HI(HI + extractl(LO, 31, 1));				\
	SET_LO(LO << 1);						\
	if ((extractl(_op1, 30 - _i, 1)) == 1)				\
	  {								\
	    /* check whether shifting the LO need to carry */           \
	    if (((unsigned)037777777777 - (unsigned)LO) < (unsigned)_op2)\
	      {								\
		SET_HI(HI + 1);						\
	      }								\
	    SET_LO(LO + _op2);						\
	  }								\
      }									\
									\
    /* take 2's complement of the result if the result is negative */	\
    if (_sign1 ^ _sign2)						\
      {									\
	SET_LO(~LO);							\
	SET_HI(~HI);							\
	if ((unsigned)LO == 037777777777)				\
	  {								\
	    SET_HI(HI + 1);						\
	  }								\
	SET_LO(LO + 1);							\
      }									\
  }
DEFINST(MULT, 			0x18,
	"mult", 		"s,t", 
	IntMULT, 		F_ICOMP|F_LONGLAT,
	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)

#define MULTU_IMPL							\
  {									\
    int _i;								\
									\
    /* HI,LO <- [rs] * [rt], integer product of [rs] & [rt] to HI/LO */	\
    SET_HI(0);								\
    SET_LO(0);								\
    if (GPR(RS) & 020000000000)						\
      SET_LO(GPR(RT));							\
									\
    for (_i = 0; _i < 31; _i++)						\
      {									\
	SET_HI(HI << 1);						\
	SET_HI(HI + extractl(LO, 31, 1));				\
	SET_LO(LO << 1);						\
	if ((extractl(GPR(RS), 30 - _i, 1)) == 1)			\
	  {								\
	    if (((unsigned)037777777777 - (unsigned)LO) < (unsigned)GPR(RT))\
	      {								\
		SET_HI(HI + 1);						\
	      }								\
	    SET_LO(LO + GPR(RT));					\
	  }								\
      }									\
  }
DEFINST(MULTU, 			0x19,
	"multu", 		"s,t", 
	IntMULT, 		F_ICOMP|F_LONGLAT,
	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)

#define DIV_IMPL							\
  {									\
    if (GPR(RT) == 0)							\
      DECLARE_FAULT(md_fault_div0);					\
									\
    SET_LO(GPR(RS) / GPR(RT));						\
    SET_HI(GPR(RS) % GPR(RT));						\
  }
DEFINST(DIV, 			0x1a,
	"div", 			"s,t", 
	IntDIV, 		F_ICOMP|F_LONGLAT,
	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)

#define DIVU_IMPL							\
  {									\
    if (GPR(RT) == 0)							\
      DECLARE_FAULT(md_fault_div0);					\
									\
    SET_LO(((unsigned)GPR(RS)) / ((unsigned)GPR(RT)));			\
    SET_HI(((unsigned)GPR(RS)) % ((unsigned)GPR(RT)));			\
  }
DEFINST(DIVU, 			0x1b,
	"divu", 		"s,t", 
	IntDIV, 		F_ICOMP|F_LONGLAT,
	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)


#define ADD_IMPL							\
  {									\
    if (OVER(GPR(RS), GPR(RT)))						\
      DECLARE_FAULT(md_fault_overflow);					\
									\
    SET_GPR(RD, GPR(RS) + GPR(RT));					\
  }
DEFINST(ADD,	 		0x20,
	"add", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)


#define ADDU_IMPL							\
  {									\
    SET_GPR(RD, GPR(RS) + GPR(RT));					\
  }
DEFINST(ADDU, 			0x21,
	"addu", 		"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)


#define SUB_IMPL							\
  {									\
    if (UNDER(GPR(RS), GPR(RT)))					\
      DECLARE_FAULT(md_fault_overflow);					\
									\
    SET_GPR(RD, GPR(RS) - GPR(RT));					\
  }
DEFINST(SUB, 			0x22,
	"sub", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)

#define SUBU_IMPL							\
  {									\
    SET_GPR(RD, GPR(RS) - GPR(RT));					\
  }
DEFINST(SUBU, 			0x23,
	"subu", 		"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
	


/* AND conflicts with GNU defs */
#define AND__IMPL							\
  {									\
    SET_GPR(RD, GPR(RS) & GPR(RT));					\
  }
DEFINST(AND_, 			0x24,
	"and", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)


#define OR_IMPL								\
  {									\
    SET_GPR(RD, GPR(RS) | GPR(RT));					\
  }
DEFINST(OR, 			0x25,
	"or", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)

#define XOR_IMPL							\
  {									\
    SET_GPR(RD, GPR(RS) ^ GPR(RT));					\
  }
DEFINST(XOR, 			0x26,
	"xor", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)

#define NOR_IMPL							\
  {									\
    SET_GPR(RD, ~(GPR(RS) | GPR(RT)));					\
  }
DEFINST(NOR, 			0x27,
	"nor", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)


#define SLT_IMPL							\
  {									\
    if (GPR(RS) < GPR(RT))						\
      SET_GPR(RD, 1);							\
    else								\
      SET_GPR(RD, 0);							\
  }
DEFINST(SLT,			0x2a,
	"slt", 			"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)

#define SLTU_IMPL							\
  {									\
    if (((unsigned)GPR(RS)) < ((unsigned)GPR(RT)))			\
      SET_GPR(RD, 1);							\
    else								\
      SET_GPR(RD, 0);							\
  }
DEFINST(SLTU, 			0x2b,
	"sltu", 		"d,s,t",
	IntALU, 		F_ICOMP,
	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)

#define TEQ_IMPL							\
  {									\
    if (GPR(RS) == GPR(RT))  {   \
        printf("TEQ trap: rs = 0x%x, rt = 0x%x\n", GPR(RS),  GPR(RT));   \
    }               \
  }

DEFINST(TEQ, 			0x34,
	"teq", 		"s,t",
	IntALU, 		F_ICOMP,
	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)


/* regimm instructions */
CONNECT(REGIMM_INST)

#define BLTZ_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) < 0)							\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BLTZ,	 		0x00,
	"bltz", 		"s,j", 
	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BGEZ_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) >= 0)							\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BGEZ, 			0x01,
	"bgez", 		"s,j", 
	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BLTZL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) < 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BLTZL,	 		0x02,
	"bltzl", 		"s,j", 
	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BGEZL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (GPR(RS) >= 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BGEZL, 			0x03,
	"bgezl", 		"s,j", 
	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BLTZAL_IMPL                                                     \
  {                                                                     \
    SET_TPC(CPC + 4 + (OFS << 2));					\
    SET_GPR(31, CPC + 8);						\
    if (GPR(RS) < 0)							\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }									
DEFINST(BLTZAL,			0x10,
	"bltzal",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)
	
#define BGEZAL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    SET_GPR(31, CPC + 8);						\
    if (GPR(RS) >= 0)							\
    {									\
      SET_NPC(CPC + 4 + (OFS << 2));					\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BGEZAL,			0x11,
	"bgezal",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

#define BLTZALL_IMPL                                                     \
  {                                                                     \
    SET_TPC(CPC + 4 + (OFS << 2));					\
    SET_GPR(31, CPC + 8);						\
    if (GPR(RS) < 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }									
DEFINST(BLTZALL,		0x12,
	"bltzall",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)
	
#define BGEZALL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    SET_GPR(31, CPC + 8);						\
    if (GPR(RS) >= 0)							\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BGEZALL,		0x13,
	"bgezall",		"s,j",
	IntALU,			F_CTRL|F_COND|F_DIRJMP,
	DNA, DNA,		DGPR(RS), DNA, DNA)

/* coprocessor 0 instructions */
/* CONNECT(COP0_INST) */
/* unimplemented */

CONNECT(COP1_INST)

#define MFC1_IMPL							\
  {									\
    SET_GPR(RT, FPR_L(FS));						\
  }
DEFINST(MFC1,	 		0x00,
	"mfc1", 		"t,S",
	IntALU, 		F_ICOMP,
	DGPR(RT), DNA,		DFPR_L(FS), DNA, DNA)

#define DMFC1_IMPL							\
  {									\
    if (((RT) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_GPR(RT, FPR_L(FS));						\
    SET_GPR((RT)+1, FPR_L((FS)+1));					\
  }
DEFINST(DMFC1, 			0x01,
	"dmfc1",		"t,S",
	IntALU,			F_ICOMP,
	DGPR_D(RT), DNA, 	DFPR_D(FS), DNA, DNA)

#define CFC1_IMPL							\
  {									\
    /* FIXME: is this needed??? */					\
  }
DEFINST(CFC1, 			0x02,
	"cfc1", 		"t,S",
	IntALU, 		F_ICOMP,
	DNA, DNA,		DNA, DNA, DNA)

#define MTC1_IMPL							\
  {									\
    SET_FPR_L(FS, GPR(RT));						\
  }
DEFINST(MTC1, 			0x04,
	"mtc1", 		"t,S",
	IntALU, 		F_ICOMP,
	DFPR_L(FS), DNA,	DGPR(RT), DNA, DNA)

#define DMTC1_IMPL							\
  {									\
    if (((FS) & 01) || ((RT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FS, GPR(RT));						\
    SET_FPR_L((FS)+1, GPR((RT)+1));					\
  }
DEFINST(DMTC1,	 		0x05,
	"dmtc1",		"t,S",
	IntALU,			F_ICOMP,
	DFPR_D(FS), DNA,	DGPR_D(RT), DNA, DNA)

#define CTC1_IMPL							\
  {									\
    /* FIXME: is this needed??? */					\
  }
DEFINST(CTC1, 			0x06,
	"ctc1", 		"t,S",
	IntALU, 		F_ICOMP,
	DNA, DNA,		DNA, DNA, DNA)

DEFLINK(FPBR_INST , 0x08, "fpbr",   16, 0x1f)

/* single precision */
DEFLINK(FPSP_INST , 0x10, "fpsp",    0, 0x3f)
/* double precision */
DEFLINK(FPDP_INST , 0x11, "fpdp",    0, 0x3f)

/* convertions */
DEFLINK(FPW_INST , 0x14, "fpw",    0, 0x3f)
/*
DEFLINK(FPL_INST , 0x15, "fpl",    0, 0x3f)
*/

CONNECT(FPBR_INST)

#define BC1F_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (!FCC)								\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BC1F, 			0x00,
	"bc1f", 		"j", 
	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
	DNA, DNA,		DFCC, DNA, DNA)

#define BC1T_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (FCC)								\
    {									\
      is_jump[pid] = 1;							\
    }									\
  }
DEFINST(BC1T, 			0x01,
	"bc1t", 		"j", 
	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
	DNA, DNA,		DFCC, DNA, DNA)


#define BC1FL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (!FCC)								\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BC1FL, 			0x02,
	"bc1fl", 		"j", 
	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
	DNA, DNA,		DFCC, DNA, DNA)

#define BC1TL_IMPL							\
  {									\
    SET_TPC(CPC + 4 + (OFS << 2));					\
    if (FCC)								\
    {									\
      is_jump[pid] = 1;							\
    }else is_annulled[pid] = 1; 						\
  }
DEFINST(BC1TL, 			0x03,
	"bc1tl", 		"j", 
	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
	DNA, DNA,		DFCC, DNA, DNA)

CONNECT(FPSP_INST)

#define FADD_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, FPR_F(FS) + FPR_F(FT));				\
  }
DEFINST(FADD_S,			0x00,
	"add.s",		"D,S,T",
	FloatADD,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)

#define FSUB_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, FPR_F(FS) - FPR_F(FT));				\
  }
DEFINST(FSUB_S,			0x01,
	"sub.s",		"D,S,T",
	FloatADD, 		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)

#define FMUL_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, FPR_F(FS) * FPR_F(FT));				\
  }
DEFINST(FMUL_S,			0x02,
	"mul.s",		"D,S,T",
	FloatMULT, 		F_FCOMP|F_LONGLAT,
	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)

#define FDIV_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, FPR_F(FS) / FPR_F(FT));				\
  }
DEFINST(FDIV_S,			0x03,
	"div.s",		"D,S,T",
	FloatDIV,		F_FCOMP|F_LONGLAT,
	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)

#define FSQRT_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, (sfloat_t)sqrt((dfloat_t)FPR_F(FS)));			\
  }
DEFINST(FSQRT_S,		0x04,
	"sqrt.s",		"D,S",
	FloatSQRT,		F_FCOMP|F_LONGLAT,
	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define FABS_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, (sfloat_t)fabs((dfloat_t)FPR_F(FS)));			\
  }
DEFINST(FABS_S,			0x05,
	"abs.s",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define FMOV_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, FPR_F(FS));						\
  }
DEFINST(FMOV_S,			0x06,
	"mov.s",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define FNEG_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, -FPR_F(FS));						\
  }
DEFINST(FNEG_S,			0x07,
	"neg.s",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define ROUND_W_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)roundf(FPR_F(FS)));					\
  }
DEFINST(ROUND_W_S,		0x0c, 
	"round.w.s", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define TRUNC_W_S_IMPL									\
  {														\
    if (((FD) & 01) || ((FS) & 01))						\
      DECLARE_FAULT(md_fault_alignment);				\
														\
    SET_FPR_L(FD, (sword_t)truncf(FPR_F(FS)));			\
  }
DEFINST(TRUNC_W_S,		0x0d, 
	"trunc.w.s", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define CEIL_W_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)ceilf(FPR_F(FS)));					\
  }
DEFINST(CEIL_W_S,		0x0e, 
	"ceil.w.s", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define FLOOR_W_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)floorf(FPR_F(FS)));					\
  }
DEFINST(FLOOR_W_S,		0x0f, 
	"floor.w.s", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define CVT_D_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, (dfloat_t)FPR_F(FS));					\
  }
DEFINST(CVT_D_S,		0x21,
	"cvt.d.s",		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_F(FS), DNA, DNA)

#define CVT_W_S_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)FPR_F(FS));					\
  }
DEFINST(CVT_W_S,		0x24,
	"cvt.w.s", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)


#define C_EQ_S_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_F(FS) == FPR_F(FT));					\
  }
DEFINST(C_EQ_S,			0x32,
	"c.eq.s", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)

#define C_LT_S_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_F(FS) < FPR_F(FT));					\
  }
DEFINST(C_LT_S,			0x3c,
	"c.lt.s", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)

#define C_LE_S_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_F(FS) <= FPR_F(FT));					\
  }
DEFINST(C_LE_S,			0x3e,
	"c.le.s", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)



/* double presicion ops */
CONNECT(FPDP_INST)

#define FADD_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, FPR_D(FS) + FPR_D(FT));				\
  }
DEFINST(FADD_D,			0x00,
	"add.d",		"D,S,T",
	FloatADD,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)


#define FSUB_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, FPR_D(FS) - FPR_D(FT));				\
  }
DEFINST(FSUB_D,			0x01,
	"sub.d",		"D,S,T",
	FloatADD, 		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)


#define FMUL_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, FPR_D(FS) * FPR_D(FT));				\
  }
DEFINST(FMUL_D, 		0x02,
	"mul.d",		"D,S,T",
	FloatMULT, 		F_FCOMP|F_LONGLAT,
	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)


#define FDIV_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, FPR_D(FS) / FPR_D(FT));				\
  }
DEFINST(FDIV_D,			0x03,
	"div.d",		"D,S,T",
	FloatDIV,		F_FCOMP|F_LONGLAT,
	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)

#define FSQRT_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, sqrt(FPR_D(FS)));					\
  }
DEFINST(FSQRT_D,		0x04,
	"sqrt.d",		"D,S",
	FloatSQRT,		F_FCOMP|F_LONGLAT,
	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)


#define FABS_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, fabs(FPR_D(FS)));					\
  }
DEFINST(FABS_D,			0x05,
	"abs.d",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)


#define FMOV_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, FPR_D(FS));						\
  }
DEFINST(FMOV_D,			0x06,
	"mov.d",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)


#define FNEG_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, -FPR_D(FS));						\
  }
DEFINST(FNEG_D,			0x07,
	"neg.d",		"D,S",
	FloatADD,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define ROUND_W_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)round(FPR_D(FS)));					\
  }
DEFINST(ROUND_W_D,		0x0c, 
	"round.w.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define TRUNC_W_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)trunc(FPR_D(FS)));					\
  }
DEFINST(TRUNC_W_D,		0x0d, 
	"trunc.w.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define CEIL_W_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)ceil(FPR_D(FS)));					\
  }
DEFINST(CEIL_W_D,		0x0e, 
	"ceil.w.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define FLOOR_W_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)floor(FPR_D(FS)));					\
  }
DEFINST(FLOOR_W_D,		0x0f, 
	"floor.w.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define CVT_S_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, (float)FPR_D(FS));					\
  }
DEFINST(CVT_S_D,	0x20, 
	"cvt.s.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_D(FS), DNA, DNA)

#define CVT_W_D_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_L(FD, (sword_t)FPR_D(FS));					\
  }
DEFINST(CVT_W_D,		0x24,
	"cvt.w.d", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)


#define C_EQ_D_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_D(FS) == FPR_D(FT));					\
  }
DEFINST(C_EQ_D,			0x32,
	"c.eq.d", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)


#define C_LT_D_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_D(FS) < FPR_D(FT));					\
  }
DEFINST(C_LT_D,			0x3c,
	"c.lt.d", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)


#define C_LE_D_IMPL							\
  {									\
    if (((FS) & 01) || ((FT) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FCC(FPR_D(FS) <= FPR_D(FT));					\
  }
DEFINST(C_LE_D,			0x3e,
	"c.le.d", 		"S,T",
	FloatCMP,		F_FCOMP,
	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)

/* to word conversions */
CONNECT(FPW_INST)

#define CVT_S_W_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_F(FD, (float)FPR_L(FS));					\
  }
DEFINST(CVT_S_W,		0x20,
	"cvt.s.w", 		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_F(FD), DNA,	DFPR_L(FS), DNA, DNA)

#define CVT_D_W_IMPL							\
  {									\
    if (((FD) & 01) || ((FS) & 01))					\
      DECLARE_FAULT(md_fault_alignment);				\
									\
    SET_FPR_D(FD, (dfloat_t)FPR_L(FS));					\
  }
DEFINST(CVT_D_W,		0x21,
	"cvt.d.w",		"D,S",
	FloatCVT,		F_FCOMP,
	DFPR_D(FD), DNA,	DFPR_L(FS), DNA, DNA)


/* clean up all definitions... */
#undef JUMP_IMPL
#undef JAL_IMPL
#undef BEQ_IMPL
#undef BNE_IMPL
#undef BLEZ_IMPL
#undef BGTZ_IMPL
#undef ADDI_IMPL
#undef ADDIU_IMPL
#undef SLTI_IMPL
#undef SLTIU_IMPL
#undef ANDI_IMPL
#undef ORI_IMPL
#undef XORI_IMPL
#undef LUI_IMPL
#undef BEQL_IMPL
#undef BNEL_IMPL
#undef BLEZL_IMPL
#undef BGTZL_IMPL
#undef LB_IMPL
#undef LH_IMPL
#undef LW_IMPL
#undef LBU_IMPL
#undef LHU_IMPL
#undef LWC1_IMPL
#undef LDC1_IMPL
#undef LWL_IMPL
#undef LWR_IMPL
#undef LWL_IMPL
#undef LWR_IMPL
#undef SB_IMPL
#undef SH_IMPL
#undef SW_IMPL
#undef SWC1_IMPL
#undef SDC1_IMPL
#undef SWL_IMPL
#undef SWR_IMPL
#undef SWL_IMPL
#undef SWR_IMPL
#undef LL_IMPL
#undef SC_IMPL
#undef SLL_IMPL
#undef SLLV_IMPL
#undef SRL_IMPL
#undef SRL_IMPL
#undef SRLV_IMPL
#undef SRLV_IMPL
#undef SRA_IMPL
#undef SRA_IMPL
#undef SRAV_IMPL
#undef SRAV_IMPL
#undef JR_IMPL
#undef JALR_IMPL
#undef SYSCALL_IMPL
#undef BREAK_IMPL
#undef MFHI_IMPL
#undef MTHI_IMPL
#undef MFLO_IMPL
#undef MTLO_IMPL
#undef MULT_IMPL
#undef MULTU_IMPL
#undef DIV_IMPL
#undef DIVU_IMPL
#undef ADD_IMPL
#undef ADDU_IMPL
#undef SUB_IMPL
#undef SUBU_IMPL
#undef AND__IMPL
#undef OR_IMPL
#undef XOR_IMPL
#undef NOR_IMPL
#undef SLT_IMPL
#undef SLTU_IMPL
#undef BLTZ_IMPL
#undef BGEZ_IMPL
#undef BLTZL_IMPL
#undef BGEZL_IMPL
#undef BLTZAL_IMPL
#undef BGEZAL_IMPL
#undef BLTZALL_IMPL
#undef BGEZALL_IMPL
#undef MFC1_IMPL
#undef DMFC1_IMPL
#undef CFC1_IMPL
#undef MTC1_IMPL
#undef DMTC1_IMPL
#undef CTC1_IMPL
#undef BC1F_IMPL
#undef BC1T_IMPL
#undef BC1FL_IMPL
#undef BC1TL_IMPL
#undef FADD_S_IMPL
#undef FSUB_S_IMPL
#undef FMUL_S_IMPL
#undef FDIV_S_IMPL
#undef FSQRT_S_IMPL
#undef FABS_S_IMPL
#undef FMOV_S_IMPL
#undef FNEG_S_IMPL
#undef C_EQ_S_IMPL
#undef C_LT_S_IMPL
#undef C_LE_S_IMPL
#undef CVT_S_D_IMPL
#undef CVT_S_W_IMPL
#undef FADD_D_IMPL
#undef FSUB_D_IMPL
#undef FMUL_D_IMPL
#undef FDIV_D_IMPL
#undef FSQRT_D_IMPL
#undef FABS_D_IMPL
#undef FMOV_D_IMPL
#undef FNEG_D_IMPL
#undef C_EQ_D_IMPL
#undef C_LT_D_IMPL
#undef C_LE_D_IMPL
#undef CVT_D_S_IMPL
#undef CVT_D_W_IMPL
#undef ROUND_W_S_IMPL
#undef ROUND_W_D_IMPL
#undef TRUNC_W_S_IMPL
#undef TRUNC_W_D_IMPL
#undef CEIL_W_S_IMPL
#undef CEIL_W_D_IMPL
#undef FLOOR_W_S_IMPL
#undef FLOOR_W_D_IMPL
#undef CVT_W_S_IMPL
#undef CVT_W_D_IMPL
#undef JUMP_IMPL
#undef JAL_IMPL
#undef BEQ_IMPL
#undef BNE_IMPL
#undef BLEZ_IMPL
#undef BGTZ_IMPL
#undef ADDI_IMPL
#undef ADDIU_IMPL
#undef SLTI_IMPL
#undef SLTIU_IMPL
#undef ANDI_IMPL
#undef ORI_IMPL
#undef XORI_IMPL
#undef LUI_IMPL
#undef BEQL_IMPL
#undef BNEL_IMPL
#undef BLEZL_IMPL
#undef BGTZL_IMPL
#undef LB_IMPL
#undef LH_IMPL
#undef LW_IMPL
#undef LBU_IMPL
#undef LHU_IMPL
#undef LWC1_IMPL
#undef LDC1_IMPL
#undef LWL_IMPL
#undef LWR_IMPL
#undef LWL_IMPL
#undef LWR_IMPL
#undef SB_IMPL
#undef SH_IMPL
#undef SW_IMPL
#undef SWC1_IMPL
#undef SDC1_IMPL
#undef SWL_IMPL
#undef SWR_IMPL
#undef SWL_IMPL
#undef SWR_IMPL
#undef LL_IMPL
#undef SC_IMPL
#undef SLL_IMPL
#undef SLLV_IMPL
#undef SRL_IMPL
#undef SRL_IMPL
#undef SRLV_IMPL
#undef SRLV_IMPL
#undef SRA_IMPL
#undef SRA_IMPL
#undef SRAV_IMPL
#undef SRAV_IMPL
#undef JR_IMPL
#undef JALR_IMPL
#undef SYSCALL_IMPL
#undef BREAK_IMPL
#undef MFHI_IMPL
#undef MTHI_IMPL
#undef MFLO_IMPL
#undef MTLO_IMPL
#undef MULT_IMPL
#undef MULTU_IMPL
#undef DIV_IMPL
#undef DIVU_IMPL
#undef ADD_IMPL
#undef ADDU_IMPL
#undef SUB_IMPL
#undef SUBU_IMPL
#undef AND__IMPL
#undef OR_IMPL
#undef XOR_IMPL
#undef NOR_IMPL
#undef SLT_IMPL
#undef SLTU_IMPL
#undef BLTZ_IMPL
#undef BGEZ_IMPL
#undef BLTZL_IMPL
#undef BGEZL_IMPL
#undef BLTZAL_IMPL
#undef BGEZAL_IMPL
#undef BLTZALL_IMPL
#undef BGEZALL_IMPL
#undef MFC1_IMPL
#undef DMFC1_IMPL
#undef CFC1_IMPL
#undef MTC1_IMPL
#undef DMTC1_IMPL
#undef CTC1_IMPL
#undef BC1F_IMPL
#undef BC1T_IMPL
#undef BC1FL_IMPL
#undef BC1TL_IMPL
#undef FADD_S_IMPL
#undef FSUB_S_IMPL
#undef FMUL_S_IMPL
#undef FDIV_S_IMPL
#undef FSQRT_S_IMPL
#undef FABS_S_IMPL
#undef FMOV_S_IMPL
#undef FNEG_S_IMPL
#undef C_EQ_S_IMPL
#undef C_LT_S_IMPL
#undef C_LE_S_IMPL
#undef CVT_S_D_IMPL
#undef CVT_S_W_IMPL
#undef FADD_D_IMPL
#undef FSUB_D_IMPL
#undef FMUL_D_IMPL
#undef FDIV_D_IMPL
#undef FSQRT_D_IMPL
#undef FABS_D_IMPL
#undef FMOV_D_IMPL
#undef FNEG_D_IMPL
#undef C_EQ_D_IMPL
#undef C_LT_D_IMPL
#undef C_LE_D_IMPL
#undef CVT_D_S_IMPL
#undef CVT_D_W_IMPL
#undef ROUND_W_S_IMPL
#undef ROUND_W_D_IMPL
#undef TRUNC_W_S_IMPL
#undef TRUNC_W_D_IMPL
#undef CEIL_W_S_IMPL
#undef CEIL_W_D_IMPL
#undef FLOOR_W_S_IMPL
#undef FLOOR_W_D_IMPL
#undef CVT_W_S_IMPL
#undef CVT_W_D_IMPL

#undef DEFINST
#undef DEFLINK
#undef CONNECT
